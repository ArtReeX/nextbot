package brain

import (
	"fmt"
	"math/rand"
	"reflect"
	"testing"
)

func ExampleNeuralNetwork() {

	// установка случайности в нулевое значение
	rand.Seed(0)

	// создание шаблона XOR для обучения сети
	patterns := [][][]float64{
		{{0, 0}, {0}},
		{{0, 1}, {1}},
		{{1, 0}, {1}},
		{{1, 1}, {0}},
	}

	// создание экземпляра нейронной сети
	network := NeuralNetwork{}

	// инициализация нейронной сети, структура сети будет содержать 2 входа, 2 скрытых узла и 1 выход
	network.Initialize(2, 2, 1)

	/*
		Обучение сети с использованием шаблона XOR:

		Тренировка будет проходить 1000 итераций,
		скорость обучения установлена равной 0.6, а коэффициент импульса - 0.4,
		последний параметр отвечает за получение отчётов об ошибках при обучении.
	*/
	network.Train(patterns, 1000, 0.6, 0.4, false)

	// тестирование обученной сети
	network.Test(patterns)

	// ручное тестирование
	fmt.Println(network.Update([]float64{1, 1}))

	// Output:
	// [0 0] -> [0.057503945708445206]  :  [0]
	// [0 1] -> [0.9301006350712101]  :  [1]
	// [1 0] -> [0.9278099662272838]  :  [1]
	// [1 1] -> [0.09740879532462123]  :  [0]
	// [0.09740879532462123]

}

// TestLoadAndSave - функция обеспечивает тестирование сохранения текущего состояния сети и последующую загрузку в нейронную сеть
func TestLoadAndSave(t *testing.T) {

	// установка случайности в нулевое значение
	rand.Seed(0)

	// создание шаблона XOR для обучения сети
	patterns := [][][]float64{
		{{0, 0}, {0}},
		{{0, 1}, {1}},
		{{1, 0}, {1}},
		{{1, 1}, {0}},
	}

	// создание первого экземпляра нейронной сети
	networkOne := NeuralNetwork{}

	// инициализация нейронной сети, структура сети будет содержать 2 входа, 2 скрытых узла и 1 выход
	networkOne.Initialize(2, 2, 1)

	/*
		Обучение сети с использованием шаблона XOR:

		Тренировка будет проходить 1000 итераций,
		скорость обучения установлена равной 0.6, а коэффициент импульса - 0.4,
		последний параметр отвечает за получение отчётов об ошибках при обучении.
	*/
	networkOne.Train(patterns, 1000, 0.6, 0.4, false)

	// получение снимка нейронной сети
	snapshot, error := networkOne.Save()
	if error != nil {
		t.Error(error)
	}

	// создание второго экземпляра нейронной сети
	networkTwo := NeuralNetwork{}

	// загрузка снимка в нейронную сеть
	error = networkTwo.Load(snapshot)
	if error != nil {
		t.Error(error)
	}

	// проверка на различия в сетях
	if !reflect.DeepEqual(networkOne, networkTwo) {
		t.Error("Error: network was not loaded correctly.")
	}

}

// TestTrain - функция обеспечивает тестирование добавление записи в нейронную сеть во время работы
func TestTrain(t *testing.T) {

	// установка случайности в нулевое значение
	rand.Seed(0)

	// создание шаблона XOR для обучения сети
	patterns := [][][]float64{
		{{0, 0}, {0}},
		{{0, 1}, {1}},
		{{1, 0}, {1}},
		{{1, 1}, {0}},
	}

	// создание экземпляра нейронной сети
	network := NeuralNetwork{}

	// инициализация нейронной сети, структура сети будет содержать 2 входа, 2 скрытых узла и 1 выход
	network.Initialize(2, 2, 1)

	/*
		Обучение сети с использованием шаблона XOR:

		Тренировка будет проходить 1000 итераций,
		скорость обучения установлена равной 0.6, а коэффициент импульса - 0.4,
		последний параметр отвечает за получение отчётов об ошибках при обучении.
	*/
	network.Train(patterns, 1000, 0.6, 0.4, false)

	// получение снимка нейронной сети до нового варианта
	dumpOne, error := network.Save()
	if error != nil {
		t.Error(error)
	}

	// дополнительная тренировка
	patterns = [][][]float64{
		{{1, 1}, {0}},
	}
	network.Train(patterns, 1000, 0.6, 0.4, false)

	// получение снимка нейронной сети после нового варианта
	dumpTwo, error := network.Save()
	if error != nil {
		t.Error(error)
	}

	// проверка на различия в сетях
	if reflect.DeepEqual(dumpOne, dumpTwo) {
		t.Error("Error: the network does not learn while working.")
	}

}
